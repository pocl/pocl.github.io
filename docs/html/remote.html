
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Remote Driver &#8212; Portable Computing Language (PoCL) 6.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Using PoCL on Android" href="android.html" />
    <link rel="prev" title="Level Zero driver" href="level0.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="android.html" title="Using PoCL on Android"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="level0.html" title="Level Zero driver"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Portable Computing Language (PoCL) 6.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="features.html" >Supported OpenCL features, device drivers</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="drivers.html" accesskey="U">Supported device drivers</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Remote Driver</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="remote-driver">
<span id="remote-label"></span><h1>Remote Driver<a class="headerlink" href="#remote-driver" title="Permalink to this headline">¶</a></h1>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>PoCL-Remote is an OpenCL driver which forwards OpenCL commands to
a remote server over network. The remote OpenCL devices are listed in
the local OpenCL platform device list and each each remote device can
be used like it was a local OpenCL device. The properties of a remote
device as queried via clGetDeviceInfo() mirror the remote physical
device’s properties etc.</p>
<p>The key differentiating aim of PoCL-Remote to other similar remote
forwarding OpenCL implementations is that the server side component
is capable of autonomously scheduling commands based on event dependencies
as well as communicating in peer-to-peer fashion with other servers in order
to not tax the client’s network connection with signaling and buffer
migrations between servers. The overall design focuses also on execution
latency, not only throughput, and is still targeted to also support
interactive low latency applications such as mixed reality.</p>
<p>On the client side PoCL-Remote is a PoCL driver backend that controls
remote devices via a control protocol and transparently exposes them to
applications as if they were local devices. On the server side, there is the
<code class="docutils literal notranslate"><span class="pre">pocld</span></code> daemon which forwards requests to remote OpenCL implementations,
which can be either PoCL-based or proprietary.</p>
<p>The PoCL-Remote client has successfully been run on PC and Android devices
and with some tweaks (dubbed “Nano-PoCL”) it has proven usable even in bare
metal firmware of low end embedded devices with limited toolchain support.
This kind of portability is a big reason why the PoCL-Remote client and core
PoCL components are written in plain C rather than C++. As a concrete example
of this embedded support is this <a class="reference external" href="https://doi.org/10.1145/3585341.3585376">demo</a>
of the PoCL-Remote client running on the “AI Deck” add-on board of a Crazyflie
nano drone.</p>
<p>Overall execution latency is optimized by leaving server side command ordering
up to the underlying OpenCL driver via translated OpenCL event dependencies.
In multi-node scenarios, communication is optimized to avoid overloading the
client link by using peer-to-peer connections for inter-server communication.
The peer-to-peer connections can optionally be made more efficient by building
the daemon with RDMA support, which then gets used when migrating buffers
between nodes. Applications that deal with variable sized data can addionally
be written to make use of the <code class="docutils literal notranslate"><span class="pre">cl_pocl_content_size</span></code> extension that lets
the runtime know that buffers don’t need to be transferred in full, which
PoCL-Remote can take advantage of both in client-server and server-to-server
communication.</p>
</section>
<section id="more-information">
<h2>More Information<a class="headerlink" href="#more-information" title="Permalink to this headline">¶</a></h2>
<p>PoCL-Remote has previously been showcased at
<a class="reference external" href="http://doi.org/10.1145/3388333.3388642">IWOCL ‘20</a>,
<a class="reference external" href="https://doi.org/10.1007/978-3-031-04580-6_6">SAMOS 2021</a> and
<a class="reference external" href="https://doi.org/10.1145/3388333.3388642">IWOCL ‘23</a>.
There is also a full length journal article under review which describes the
published version (for example its RDMA support). A preprint of the article is
available in <a class="reference external" href="https://doi.org/10.48550/arXiv.2309.00407">arXiv</a>.</p>
<p>In publications, when referring to PoCL-R, please cite the introductory paper with the following format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@InProceedings</span><span class="p">{</span><span class="mf">10.1007</span><span class="o">/</span><span class="mi">978</span><span class="o">-</span><span class="mi">3</span><span class="o">-</span><span class="mi">031</span><span class="o">-</span><span class="mi">04580</span><span class="o">-</span><span class="mi">6_6</span><span class="p">,</span>
<span class="n">author</span><span class="o">=</span><span class="s2">&quot;Solanti, Jan and Babej, Michal and Ikkala, Julius and Malamal Vadakital, Vinod Kumar and J{</span><span class="se">\&quot;</span><span class="s2">a}{</span><span class="se">\&quot;</span><span class="s2">a}skel{</span><span class="se">\&quot;</span><span class="s2">a}inen, Pekka&quot;</span><span class="p">,</span>
<span class="n">title</span><span class="o">=</span><span class="s2">&quot;PoCL-R: A Scalable Low Latency Distributed OpenCL Runtime&quot;</span><span class="p">,</span>
<span class="n">booktitle</span><span class="o">=</span><span class="s2">&quot;Embedded Computer Systems: Architectures, Modeling, and Simulation&quot;</span><span class="p">,</span>
<span class="n">year</span><span class="o">=</span><span class="s2">&quot;2022&quot;</span><span class="p">,</span>
<span class="n">pages</span><span class="o">=</span><span class="s2">&quot;78--94&quot;</span><span class="p">,</span>
<span class="n">isbn</span><span class="o">=</span><span class="s2">&quot;978-3-031-04580-6&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<p>A machine with a working OpenCL implementation (can be any proprietary or
pocl-based) to act as a server, and another machine as a client which runs the
OpenCL application. Naturally, it’s possible to use the same machine for both
for testing purposes.</p>
<p>The remote driver has been tested so far with AMD, NVidia and Intel OpenCL
implementations as well as with PoCL’s CPU backend.</p>
</section>
<section id="current-status">
<h2>Current Status<a class="headerlink" href="#current-status" title="Permalink to this headline">¶</a></h2>
<p>The current version has been tested with various programs, such as:</p>
<blockquote>
<div><ul class="simple">
<li><p>the builtin tests of pocl</p></li>
<li><p>AMD’s Baikal ray-tracing application</p></li>
<li><p>Luxmark</p></li>
<li><p>FluidX3D</p></li>
</ul>
</div></blockquote>
<p>The image support in particular is quite new and very lightly tested.
The same applies for multi-device setup.</p>
<p>printf() support exists, but please note that the “standard output” (stdout) of the server-side OpenCL will be printed to the PoCL-D stdout. Furthermore, the stdout is shared with all client-server connection, so if multiple client
devices launch kernels with printf() simultaneously, the output order is
undefined.</p>
</section>
<section id="known-bugs-issues-wip">
<h2>Known Bugs/Issues/WiP<a class="headerlink" href="#known-bugs-issues-wip" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>The “-I” option to clBuildProgram does not work</p></li>
<li><p>clGetKernelWorkGroupInfo() can return incorrect information</p></li>
<li><p>clCompileProgram() and clLinkProgram() API calls are broken</p></li>
<li><p>clSetKernelArg() will not return a CL_INVALID_ARG_SIZE error if arg_size does not
match the size of the data type for an argument that is not a memory object.
Fixing this would require involving LLVM on the client side, as argument size
information cannot be retrieved from OpenCL API runtime calls.</p></li>
<li><p>There are some hardcoded limits (max devices per server)</p></li>
</ul>
</section>
<section id="known-bugs-issues-in-opencl-implementations">
<span id="remote-issues-label"></span><h2>Known Bugs/Issues in OpenCL Implementations<a class="headerlink" href="#known-bugs-issues-in-opencl-implementations" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Nvidia’s OpenCL implementation has a bug where clCreateKernelsInProgram()
sometimes fails. This affects pocld since it uses clCreateKernelsInProgram
in background.
Workaround: always build programs for all devices. More details:
<a class="reference external" href="https://devtalk.nvidia.com/default/topic/995251/clcreatekernelsinprogram-strangely-returns-cl_invalid_kernel_definition/">https://devtalk.nvidia.com/default/topic/995251/clcreatekernelsinprogram-strangely-returns-cl_invalid_kernel_definition/</a></p></li>
<li><p>ARM Mali OpenCL SDK (on Linux) and some Android OpenCL implementations fail
to return anything for clGetKernelArgInfo calls,
so it’s unusable by itself (as backend for the proxy driver or for pocld).
It is usable if pocl is built with at least two drivers (proxy/remote/pthread
etc) of which at least one provides the build information.
For OpenCL (pocl) users, it means all CL programs (to be used with Mali) must
be built for at least two devices from two drivers,
so the other driver provides the build information Mali does not.
This Mali bug is only fixable by using another driver, or writing some extra
compilation/parsing step, because without argument metadata
it’s impossible to tell if an argument to clSetKernelArg is a pointer or an integer.</p></li>
</ul>
</section>
<section id="how-to-build">
<h2>How to Build<a class="headerlink" href="#how-to-build" title="Permalink to this headline">¶</a></h2>
<p>First you need to install the build dependencies.
These are listed in <a class="reference internal" href="install.html#pocl-install"><span class="std std-ref">Installation</span></a> or alternatively you can
also take a look at the Dockerfiles in <code class="docutils literal notranslate"><span class="pre">tools/docker</span></code>.</p>
<p>Note that you do not need LLVM if you want to only use the PoCL-Remote driver
to control server side devices for which a separate OpenCL driver exists.</p>
<p>These steps build pocl <strong>without</strong> the CPU driver (= with remote driver only).</p>
<p>If you want to use event tracing/profiling, scroll below as it requires
installing some extra packages before building pocl.</p>
<p>To build the remote <em>client</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>mkdir build; cd build;
cmake -DENABLE_HOST_CPU_DEVICES=0 -DENABLE_LLVM=0 -DENABLE_LOADABLE_DRIVERS=0 -DENABLE_ICD=1 -DENABLE_REMOTE_CLIENT=1 ..
make -j$(nproc)
</pre></div>
</div>
<p>This should produce <strong>lib/CL/libpocl.so</strong> (the client library that implements
the OpenCL runtime API).</p>
<p>To build the remote <em>server</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mkdir</span> <span class="n">build</span><span class="p">;</span> <span class="n">cd</span> <span class="n">build</span><span class="p">;</span>
<span class="n">cmake</span> <span class="o">../</span><span class="n">pocld</span>
</pre></div>
</div>
<p>This should produce <strong>pocld</strong> (the server executable). If you need both the
client library and server binary on the same machine you can alternatively add
<code class="docutils literal notranslate"><span class="pre">-DENABLE_REMOTE_SERVER=1</span></code> to the cmake flags in the client build to get
<strong>pocld/pocld</strong> generated in the same build directory.</p>
<p>On the server, make sure that “clinfo” lists at least one OpenCL device, then
run the server command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">pocld</span> <span class="o">-</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">IP</span> <span class="n">ADDRESS</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">p</span> <span class="o">&lt;</span><span class="n">PORT</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Run <code class="docutils literal notranslate"><span class="pre">pocld</span> <span class="pre">--help</span></code> to list all options.
Note that pocld will listen on three ports, <code class="docutils literal notranslate"><span class="pre">PORT</span></code>, <code class="docutils literal notranslate"><span class="pre">PORT+1</span></code> and <code class="docutils literal notranslate"><span class="pre">PORT+2</span></code>.
You can tune the amount of messages produced with the environment variable
“POCLD_LOGLEVEL” before running pocld. The default log level is “err”.
Accepted values are: debug, info, warn, err, critical, off.</p>
<p>On the client, export these environment variables (the first one must be done
in the pocl remote-client build directory)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>export OCL_ICD_VENDORS=$PWD/ocl-vendors/pocl-tests.icd
export POCL_DEVICES=remote
export POCL_REMOTE0_PARAMETERS=&#39;&lt;IP ADDRESS&gt;:&lt;PORT&gt;/&lt;DEVICE ID&gt;#&lt;PEER ADDRESS&gt;&#39;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">IP</span> <span class="pre">ADDRESS</span></code> and <code class="docutils literal notranslate"><span class="pre">PORT</span></code> are self-explanatory, <code class="docutils literal notranslate"><span class="pre">DEVICE</span> <span class="pre">ID</span></code> is the index of
the device on the server. <code class="docutils literal notranslate"><span class="pre">PORT</span></code> is the lower port number assigned to the server.
Indices are from zero to N-1 where N is the total number of devices across
all platforms on the server.
The index is the order in which pocld lists the devices in the OpenCL platform it uses.
This is the same order than can be displayed  by “clinfo”.</p>
<p><code class="docutils literal notranslate"><span class="pre">PEER</span> <span class="pre">ADDRESS</span></code> (and the preceding ‘#’ sign) is optional and is used for server-server
communication when there are multiple remote servers that have a public IP and
a private IP on a fast internal network. If a separate peer address is not given,
server-server communication will use <code class="docutils literal notranslate"><span class="pre">IP</span> <span class="pre">ADDRESS</span></code> just like client-server communications.</p>
<p>To “smoke test” that the distributed setup works, you can use the clinfo
tool, which should now list the remote devices also:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ clinfo | grep PoCL-Remote
Device Version OpenCL 1.2 CUDA HSTR: PoCL-Remote 123.456.789.123:1000/0
</pre></div>
</div>
<p>Then you can run the simple dot product in example1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd examples/example1
$ ./example1
(0.000000, 0.000000, 0.000000, 0.000000) . (0.000000, 0.000000, 0.000000, 0.000000) = 0.000000
(1.000000, 1.000000, 1.000000, 1.000000) . (1.000000, 1.000000, 1.000000, 1.000000) = 4.000000
(2.000000, 2.000000, 2.000000, 2.000000) . (2.000000, 2.000000, 2.000000, 2.000000) = 16.000000
(3.000000, 3.000000, 3.000000, 3.000000) . (3.000000, 3.000000, 3.000000, 3.000000) = 36.000000
OK
</pre></div>
</div>
<section id="android-build-client-only">
<h3>Android Build (Client Only)<a class="headerlink" href="#android-build-client-only" title="Permalink to this headline">¶</a></h3>
<p>See <a class="reference internal" href="android.html#android-label"><span class="std std-ref">Using PoCL on Android</span></a> on how to do this.</p>
</section>
<section id="windows-build-server-only">
<h3>Windows build (server only)<a class="headerlink" href="#windows-build-server-only" title="Permalink to this headline">¶</a></h3>
<p>Only the remote server can be built on Windows.</p>
<p>Note that later versions of the Khronos ICD have problems compiling with MSYS’s GCC.
Git version from before Oct 3 2017 is known to compile. This is because apparently
MS decided to forbid the graphics drivers from writing to some Windows registry entries in
some later versions of Windows 10, and the Khronos ICD couldn’t find the list of OpenCL
implementations in the same Windows registry entries as before, so the Khronos ICD
gained some new code which uses new &amp; awesome way to enumerate the OpenCL implementations
- but this code does not compile under MSYS.</p>
<p>Possible workaround (untested): manually add OpenCL implementations to old registry paths
(example is in <a class="reference external" href="https://github.com/KhronosGroup/OpenCL-ICD-Loader/blob/master/README.txt">https://github.com/KhronosGroup/OpenCL-ICD-Loader/blob/master/README.txt</a>).</p>
<p>First, install MSYS2 from <a class="reference external" href="https://www.msys2.org/">https://www.msys2.org/</a>; only tested the x86_64
version has been tested. Follow the instructions to update all MSYS2 packages.
Then install CMake, GCC and friends:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pacman</span> <span class="o">-</span><span class="n">S</span> <span class="n">cmake</span> <span class="n">make</span> <span class="n">gcc</span> <span class="n">patch</span>
</pre></div>
</div>
<p>Download Khronos ICD loader from <a class="reference external" href="https://github.com/KhronosGroup/OpenCL-ICD-Loader">https://github.com/KhronosGroup/OpenCL-ICD-Loader</a>
and Khronos OpenCL headers from <a class="reference external" href="https://github.com/KhronosGroup/OpenCL-Headers">https://github.com/KhronosGroup/OpenCL-Headers</a></p>
<ul class="simple">
<li><p>put the PoCL-Remote and ICD loader sources in <code class="docutils literal notranslate"><span class="pre">$HOME/pocl</span></code> and <code class="docutils literal notranslate"><span class="pre">$HOME/ICD</span></code></p></li>
<li><p>patch the ICD loader with <code class="docutils literal notranslate"><span class="pre">&lt;pocl_sources&gt;/tools/patches/windows_khronos_icd.patch</span></code></p></li>
<li><p>from the OpenCL headers, take the “CL” directory and put it into <code class="docutils literal notranslate"><span class="pre">$HOME/ICD/inc/</span></code></p></li>
</ul>
<p>To build the ICD loader library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd $HOME/ICD
mkdir b
cd b
cmake -DCMAKE_SYSTEM_NAME=Windows -DCMAKE_BUILD_TYPE=RelWithDebInfo ..
make -j4
</pre></div>
</div>
<p>To build pocl:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd $HOME/pocl
mkdir b
cd b
cmake -DCMAKE_SYSTEM_NAME=MSYS -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLIBOPENCL=$HOME/ICD/b ../pocld
make -j8
</pre></div>
</div>
<p>This will result in pocld.exe in <code class="docutils literal notranslate"><span class="pre">$HOME/pocl/b</span></code> directory. This requires a few DLLs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">msys-2.0.dll</span>&#160; <span class="pre">msys-gcc_s-seh-1.dll</span>&#160; <span class="pre">msys-stdc++-6.dll</span></code> from <code class="docutils literal notranslate"><span class="pre">$MSYS/usr/bin</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">libOpenCL.dll</span></code>  from <code class="docutils literal notranslate"><span class="pre">$HOME/ICD/b/bin</span></code></p></li>
</ul>
<p>These can be copied into the same directory as pocld.exe. The binary is quite large;
if debugging symbols are not needed, <code class="docutils literal notranslate"><span class="pre">strip.exe</span></code> command works as on Linux.</p>
</section>
</section>
<section id="event-tracing">
<h2>Event Tracing<a class="headerlink" href="#event-tracing" title="Permalink to this headline">¶</a></h2>
<p>It’s possible to use LTTNG to trace both the server and the client library.
To install lttng on Ubuntu, run this as root / sudo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">apt</span> <span class="n">install</span> <span class="n">lttng</span><span class="o">-</span><span class="n">tools</span> <span class="n">lttng</span><span class="o">-</span><span class="n">modules</span><span class="o">-</span><span class="n">dkms</span> <span class="n">liblttng</span><span class="o">-</span><span class="n">ust</span><span class="o">-</span><span class="n">dev</span> <span class="n">liblttng</span><span class="o">-</span><span class="n">ctl</span><span class="o">-</span><span class="n">dev</span>
</pre></div>
</div>
<p>You must now run cmake with <code class="docutils literal notranslate"><span class="pre">-DENABLE_LTTNG=YES</span></code> and rebuild pocl.</p>
<section id="using-lttng">
<h3>Using LTTNG<a class="headerlink" href="#using-lttng" title="Permalink to this headline">¶</a></h3>
<p>First, check that lttng-sessiond is running. If it’s not, start it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lttng</span><span class="o">-</span><span class="n">sessiond</span> <span class="o">--</span><span class="n">daemonize</span>
</pre></div>
</div>
<p>Then launch the pocld server / OpenCL client app / both. Note that LTTNG sessiond
registers userspace events only AFTER the program has started and loaded the lttng
library. This is OK for the server, but a problem for the client, since many OpenCL
clients immediately start execution. There is an environment variable to help
with this: <code class="docutils literal notranslate"><span class="pre">POCL_STARTUP_DELAY=&lt;N&gt;</span></code> where N is the delay in seconds. You’ll also
need to enable tracing for the client application with <code class="docutils literal notranslate"><span class="pre">POCL_TRACING</span></code> so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">POCL_STARTUP_DELAY</span><span class="o">=&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">POCL_TRACING</span><span class="o">=</span><span class="n">lttng</span> <span class="n">application</span> <span class="p">[</span><span class="n">arguments</span><span class="p">]</span>
</pre></div>
</div>
<p>To create a LTTNG session:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lttng</span> <span class="n">create</span> <span class="o">&lt;</span><span class="n">session</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Now list the userspace events:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lttng</span> <span class="nb">list</span> <span class="o">--</span><span class="n">userspace</span>
</pre></div>
</div>
<p>You should see “pocl_trace:” events for the client, and “pocld_trace:” events
for the server. Enable the ones you care about, or all:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lttng</span> <span class="n">enable</span><span class="o">-</span><span class="n">event</span> <span class="o">--</span><span class="n">userspace</span> <span class="n">pocl_trace</span><span class="p">:</span><span class="o">*</span>
<span class="n">lttng</span> <span class="n">enable</span><span class="o">-</span><span class="n">event</span> <span class="o">--</span><span class="n">userspace</span> <span class="n">pocld_trace</span><span class="p">:</span><span class="o">*</span>
</pre></div>
</div>
<p>You can trace any number/combination of events, and also kernelspace events
(probably requires root).</p>
<p>To start tracing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lttng</span> <span class="n">start</span>
</pre></div>
</div>
<p>To stop tracing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lttng</span> <span class="n">stop</span>
</pre></div>
</div>
<p>To destroy session (this merely destroys session in the daemon, does not delete data):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lttng</span> <span class="n">destroy</span>
</pre></div>
</div>
<p>Now you have tracing data in <code class="docutils literal notranslate"><span class="pre">$HOME/lttng-traces/&lt;session-name&gt;-&lt;date&gt;-&lt;time&gt;</span></code>
directory. You can view them using “babeltrace” tool, or eclipse-based “trace compass”,
or possibly other tools.</p>
</section>
<section id="viewing-traces">
<h3>Viewing Traces<a class="headerlink" href="#viewing-traces" title="Permalink to this headline">¶</a></h3>
<p>For this you’ll need chrome/chromium, python and babeltrace installed.
START_TIME and END_TIME are optional - they define a time
slice to pick from the log. If not defined, the entire
trace log will be converted to JSON (Warning : large logs can be a problem).</p>
<p>To convert binary LTTNG trace format to text, then to JSON, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd $HOME/lttng-traces/&lt;session-name&gt;-&lt;date&gt;-&lt;time&gt;
babeltrace --clock-seconds . &gt;/tmp/trace.text
./&lt;pocl_source&gt;/tools/scripts/babel_parse.py -o OUTPUT_FILE /tmp/trace.txt
</pre></div>
</div>
<p>To view the JSON trace, open Google Chrome/Chromium, type <code class="docutils literal notranslate"><span class="pre">chrome://tracing</span></code>,
click Load, and find <code class="docutils literal notranslate"><span class="pre">/tmp/trace.json</span></code>.</p>
</section>
<section id="remote-and-local-traces">
<h3>Remote and Local Traces<a class="headerlink" href="#remote-and-local-traces" title="Permalink to this headline">¶</a></h3>
<p>It’s possible to combine local and remote tracing outputs to get a full view
of what’s happening over network. Note that this requires LTTNG installed on
servers as well, plus it requires very precisely synchronized time between all
involved machines (1 microsecond or so should be good enough). The simplest
way to achieve that seems to have all machines are equipped with an Intel NIC,
and then setup PTP (Precision time protocol). Note that PTP requires hardware
support from <em>every</em> network device in path to achieve sub-microsecond precision.</p>
</section>
<section id="distributed-sycl-execution-using-pocl-r">
<h3>Distributed SYCL Execution Using PoCL-R<a class="headerlink" href="#distributed-sycl-execution-using-pocl-r" title="Permalink to this headline">¶</a></h3>
<p>oneAPI DPC++ can be used to distribute SYCL applications using PoCL-R. Notably,
only buffer-based memory management (not USM) works currently. To test it out,
build DPC++ as instructed in the <a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/GetStartedGuide.md">Getting Started with oneAPI DPC++</a> document.</p>
<p>Then, build a SYCL program of your choice as instructed in the DPC++ documentation and launch it like any OpenCL program with the PoCL-D running. Just ensure you use an OpenCL device in DPC++ and it points to a PoCL-R device:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>export POCL_DEVICES=remote
export POCL_REMOTE0_PARAMETERS=localhost:7777/0
export ONEAPI_DEVICE_SELECTOR=opencl:0
./simple-sycl-app
The results are correct!
</pre></div>
</div>
</section>
</section>
<section id="implementation-notes">
<h2>Implementation Notes<a class="headerlink" href="#implementation-notes" title="Permalink to this headline">¶</a></h2>
<p>Although PoCL-R has been in development for several years it has only seen
limited testing outside the original lab since it has not been publicly available.</p>
<ul class="simple">
<li><p>The current implementation is asynchronous across multiple command queues, but
blocking within a command queue. In other words, multiple CQs progress
in parallel, but each enqueued command has an implicit clFinish() and
there is network communication before the next command is launched.
This is a key bottleneck that will be resolved in a future version.</p></li>
<li><p>For the time being the client side part of PoCL-Remote must be built with the
<code class="docutils literal notranslate"><span class="pre">ENABLE_LOADABLE_DRIVERS</span></code> build option set to <code class="docutils literal notranslate"><span class="pre">OFF</span></code>. See <a class="reference external" href="https://github.com/pocl/pocl/issues/1297">issue 1297</a>.</p></li>
<li><p>The old SPIR 1.2/2.0 are not supported and the respective extension is masked out from
remote devices’ extension lists by pocld.</p></li>
<li><p>There is no authentication or encryption whatsoever of network traffic. Don’t
use PoCL-Remote outside of closed private networks.</p></li>
<li><p>Synchronous commands (like clCreate* / clBuildProgram etc) are run in a separate thread.</p></li>
<li><p>There are two separate network connections (TCP ports) used by the driver;
one is for large transfers (like buffer transfers) and the other for fast / small
transfers (clEnqueueNDRange).</p></li>
<li><p>The client and server CPUs must be both little-endian, but may differ in
pointer size, although things may break in unexpected ways if using images
or buffers larger than 4G.</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Remote Driver</a><ul>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#more-information">More Information</a></li>
<li><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li><a class="reference internal" href="#current-status">Current Status</a></li>
<li><a class="reference internal" href="#known-bugs-issues-wip">Known Bugs/Issues/WiP</a></li>
<li><a class="reference internal" href="#known-bugs-issues-in-opencl-implementations">Known Bugs/Issues in OpenCL Implementations</a></li>
<li><a class="reference internal" href="#how-to-build">How to Build</a><ul>
<li><a class="reference internal" href="#android-build-client-only">Android Build (Client Only)</a></li>
<li><a class="reference internal" href="#windows-build-server-only">Windows build (server only)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#event-tracing">Event Tracing</a><ul>
<li><a class="reference internal" href="#using-lttng">Using LTTNG</a></li>
<li><a class="reference internal" href="#viewing-traces">Viewing Traces</a></li>
<li><a class="reference internal" href="#remote-and-local-traces">Remote and Local Traces</a></li>
<li><a class="reference internal" href="#distributed-sycl-execution-using-pocl-r">Distributed SYCL Execution Using PoCL-R</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-notes">Implementation Notes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="level0.html"
                        title="previous chapter">Level Zero driver</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="android.html"
                        title="next chapter">Using PoCL on Android</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/remote.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="android.html" title="Using PoCL on Android"
             >next</a> |</li>
        <li class="right" >
          <a href="level0.html" title="Level Zero driver"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Portable Computing Language (PoCL) 6.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="features.html" >Supported OpenCL features, device drivers</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="drivers.html" >Supported device drivers</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Remote Driver</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-2023 PoCL developers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>